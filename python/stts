#!/usr/bin/env python3
"""
stts (python) - Universal STT/TTS Shell Wrapper

Usage:
  ./stts                      # Interactive voice shell
  ./stts --setup              # Configure STT/TTS providers
  ./stts [cmd] [args...]      # Run command with voice output

Testing / simulation:
  ./stts --stt-file file.wav --stt-only
  ./stts --stt-file file.wav            # transcribe and execute

Notes:
  - Config stored in ~/.config/stts-python/
"""

import os
import sys
import json
import subprocess
import platform
import shutil
import urllib.request
import tarfile
import zipfile
import threading
import readline
import atexit
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, List, Tuple

CONFIG_DIR = Path.home() / ".config" / "stts-python"
CONFIG_FILE = CONFIG_DIR / "config.json"
MODELS_DIR = CONFIG_DIR / "models"
HISTORY_FILE = CONFIG_DIR / "history"

DEFAULT_CONFIG = {
    "stt_provider": None,
    "tts_provider": None,
    "stt_model": None,
    "tts_voice": "pl",
    "language": "pl",
    "timeout": 5,
    "auto_tts": True,
}

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[0;33m'
    BLUE = '\033[0;34m'
    MAGENTA = '\033[0;35m'
    CYAN = '\033[0;36m'
    BOLD = '\033[1m'
    NC = '\033[0m'


def cprint(color: str, text: str, end: str = "\n"):
    print(f"{color}{text}{Colors.NC}", end=end, flush=True)


def _download_progress(count, block_size, total_size):
    percent = int(count * block_size * 100 / total_size) if total_size > 0 else 0
    print(f"\r  Progress: {percent}%", end="", flush=True)


@dataclass
class SystemInfo:
    os_name: str
    os_version: str
    arch: str
    cpu_cores: int
    ram_gb: float
    gpu_name: Optional[str]
    gpu_vram_gb: Optional[float]
    is_rpi: bool
    has_mic: bool


def detect_system() -> SystemInfo:
    os_name = platform.system().lower()
    os_version = platform.release()
    arch = platform.machine()
    cpu_cores = os.cpu_count() or 1

    ram_gb = 4.0
    try:
        if os_name == "linux":
            with open("/proc/meminfo") as f:
                for line in f:
                    if line.startswith("MemTotal:"):
                        ram_kb = int(line.split()[1])
                        ram_gb = ram_kb / 1024 / 1024
                        break
    except:
        pass

    gpu_name = None
    gpu_vram_gb = None
    try:
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=name,memory.total", "--format=csv,noheader,nounits"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            parts = result.stdout.strip().split(", ")
            gpu_name = parts[0]
            gpu_vram_gb = float(parts[1]) / 1024 if len(parts) > 1 else None
    except:
        pass

    is_rpi = False
    try:
        if os_name == "linux" and Path("/proc/device-tree/model").exists():
            model = Path("/proc/device-tree/model").read_text()
            is_rpi = "raspberry" in model.lower()
    except:
        pass

    has_mic = False
    try:
        if os_name == "linux":
            result = subprocess.run(["arecord", "-l"], capture_output=True, text=True)
            has_mic = "card" in result.stdout.lower()
        else:
            has_mic = True
    except:
        pass

    return SystemInfo(
        os_name=os_name,
        os_version=os_version,
        arch=arch,
        cpu_cores=cpu_cores,
        ram_gb=round(ram_gb, 1),
        gpu_name=gpu_name,
        gpu_vram_gb=round(gpu_vram_gb, 1) if gpu_vram_gb else None,
        is_rpi=is_rpi,
        has_mic=has_mic,
    )


def load_config() -> dict:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    if CONFIG_FILE.exists():
        try:
            return json.loads(CONFIG_FILE.read_text())
        except:
            pass
    return DEFAULT_CONFIG.copy()


def save_config(config: dict) -> None:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_FILE.write_text(json.dumps(config, indent=2))


class STTProvider:
    name: str = "base"
    description: str = "Base"
    min_ram_gb: float = 0.5
    models: List[Tuple[str, str, float]] = []

    @classmethod
    def is_available(cls, info: SystemInfo):
        return False, "Not implemented"

    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        return False

    @classmethod
    def get_recommended_model(cls, info: SystemInfo) -> Optional[str]:
        return None

    def __init__(self, model: Optional[str] = None, language: str = "pl"):
        self.model = model
        self.language = language

    def transcribe(self, audio_path: str) -> str:
        raise NotImplementedError


class WhisperCppSTT(STTProvider):
    name = "whisper.cpp"
    description = "Offline, fast, CPU-optimized Whisper (recommended)"
    min_ram_gb = 1.0
    models = [
        ("tiny", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin", 0.08),
        ("base", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-base.bin", 0.15),
        ("small", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-small.bin", 0.5),
        ("medium", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-medium.bin", 1.5),
        ("large", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-large-v3.bin", 3.0),
    ]

    @classmethod
    def is_available(cls, info: SystemInfo):
        if shutil.which("whisper-cpp") or shutil.which("main"):
            return True, "whisper.cpp found"
        whisper_bin = MODELS_DIR / "whisper.cpp" / "main"
        if whisper_bin.exists():
            return True, f"whisper.cpp at {whisper_bin}"
        return False, "whisper.cpp not installed"

    @classmethod
    def get_recommended_model(cls, info: SystemInfo) -> str:
        if info.ram_gb < 2:
            return "tiny"
        if info.ram_gb < 4:
            return "base"
        if info.ram_gb < 8:
            return "small"
        if info.ram_gb < 16:
            return "medium"
        return "large"

    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        cprint(Colors.YELLOW, "üì¶ Installing whisper.cpp...")
        whisper_dir = MODELS_DIR / "whisper.cpp"
        whisper_dir.mkdir(parents=True, exist_ok=True)
        try:
            if not (whisper_dir / "Makefile").exists():
                subprocess.run(
                    ["git", "clone", "https://github.com/ggerganov/whisper.cpp", str(whisper_dir)],
                    check=True,
                )
            subprocess.run(["make", "-j"], cwd=whisper_dir, check=True)
            cprint(Colors.GREEN, "‚úÖ whisper.cpp installed!")
            return True
        except Exception as e:
            cprint(Colors.RED, f"‚ùå Installation failed: {e}")
            return False

    @classmethod
    def download_model(cls, model_name: str) -> Optional[Path]:
        model_info = next((m for m in cls.models if m[0] == model_name), None)
        if not model_info:
            cprint(Colors.RED, f"‚ùå Unknown model: {model_name}")
            return None

        name, url, size = model_info
        model_path = MODELS_DIR / "whisper.cpp" / f"ggml-{name}.bin"
        if model_path.exists():
            return model_path

        cprint(Colors.YELLOW, f"üì• Downloading {name} model ({size} GB)...")
        model_path.parent.mkdir(parents=True, exist_ok=True)
        try:
            urllib.request.urlretrieve(url, model_path, _download_progress)
            print()
            cprint(Colors.GREEN, f"‚úÖ Model {name} downloaded!")
            return model_path
        except Exception as e:
            cprint(Colors.RED, f"‚ùå Download failed: {e}")
            return None

    def transcribe(self, audio_path: str) -> str:
        whisper_bin = shutil.which("whisper-cpp") or shutil.which("main")
        if not whisper_bin:
            whisper_bin = str(MODELS_DIR / "whisper.cpp" / "main")

        model_path = MODELS_DIR / "whisper.cpp" / f"ggml-{self.model or 'base'}.bin"
        if not model_path.exists():
            model_path = self.download_model(self.model or "base")

        if not model_path:
            return ""

        try:
            result = subprocess.run(
                [whisper_bin, "-m", str(model_path), "-l", self.language, "-f", audio_path, "-nt"],
                capture_output=True,
                text=True,
                timeout=120,
            )
            return result.stdout.strip()
        except Exception as e:
            cprint(Colors.RED, f"‚ùå Transcription error: {e}")
            return ""


class TTSProvider:
    name: str = "base"

    @classmethod
    def is_available(cls, info: SystemInfo):
        return False, "Not implemented"

    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        return False

    def __init__(self, voice: str = "pl"):
        self.voice = voice

    def speak(self, text: str) -> None:
        raise NotImplementedError


class EspeakTTS(TTSProvider):
    name = "espeak"

    @classmethod
    def is_available(cls, info: SystemInfo):
        if shutil.which("espeak") or shutil.which("espeak-ng"):
            return True, "espeak found"
        return False, "apt install espeak / espeak-ng"

    def speak(self, text: str) -> None:
        cmd = shutil.which("espeak-ng") or shutil.which("espeak")
        if cmd:
            subprocess.run(
                [cmd, "-v", self.voice, "-s", "160", text],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )


STT_PROVIDERS = {"whisper_cpp": WhisperCppSTT}
TTS_PROVIDERS = {"espeak": EspeakTTS}


def record_audio(duration: int = 5, output_path: str = "/tmp/stts_audio.wav") -> str:
    info = detect_system()
    cprint(Colors.GREEN, f"üé§ M√≥w ({duration}s)...", end=" ")
    try:
        if info.os_name == "linux":
            subprocess.run(
                ["arecord", "-d", str(duration), "-f", "cd", "-t", "wav", output_path],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=duration + 2,
            )
            print("‚úÖ")
            return output_path
        cprint(Colors.RED, "‚ùå Recording supported only on Linux in this minimal build")
        return ""
    except Exception as e:
        cprint(Colors.RED, f"‚ùå Recording failed: {e}")
        return ""


def interactive_setup() -> dict:
    config = load_config()
    info = detect_system()

    cprint(Colors.BOLD + Colors.CYAN, "\nSTTS (python) - Setup\n")
    print(f"OS={info.os_name} RAM={info.ram_gb}GB GPU={info.gpu_name or 'none'}")

    stt_cls = WhisperCppSTT
    available, reason = stt_cls.is_available(info)
    print(f"STT: {stt_cls.name} ({reason})")
    if not available:
        if input("Install whisper.cpp now? (y/n): ").strip().lower() == "y":
            stt_cls.install(info)

    rec = stt_cls.get_recommended_model(info)
    model = input(f"Whisper model [tiny/base/small/medium/large] (ENTER={rec}): ").strip() or rec
    config["stt_provider"] = "whisper_cpp"
    config["stt_model"] = model

    if input(f"Download model {model} now? (y/n): ").strip().lower() == "y":
        stt_cls.download_model(model)

    tts_cls = EspeakTTS
    available, reason = tts_cls.is_available(info)
    print(f"TTS: {tts_cls.name} ({reason})")
    if not available:
        cprint(Colors.YELLOW, "Install espeak: sudo apt install espeak")

    config["tts_provider"] = "espeak" if available else None

    save_config(config)
    cprint(Colors.GREEN, f"‚úÖ Saved: {CONFIG_FILE}")
    return config


class VoiceShell:
    def __init__(self, config: dict):
        self.config = config
        self.info = detect_system()
        self.stt = self._init_stt()
        self.tts = self._init_tts()

        HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
        if HISTORY_FILE.exists():
            readline.read_history_file(str(HISTORY_FILE))
        atexit.register(lambda: readline.write_history_file(str(HISTORY_FILE)))

    def _init_stt(self) -> Optional[STTProvider]:
        provider = self.config.get("stt_provider")
        if provider in STT_PROVIDERS:
            cls = STT_PROVIDERS[provider]
            available, _ = cls.is_available(self.info)
            if available:
                return cls(model=self.config.get("stt_model"), language=self.config.get("language", "pl"))
        return None

    def _init_tts(self) -> Optional[TTSProvider]:
        provider = self.config.get("tts_provider")
        if provider in TTS_PROVIDERS:
            cls = TTS_PROVIDERS[provider]
            available, _ = cls.is_available(self.info)
            if available:
                return cls(voice=self.config.get("tts_voice", "pl"))
        if shutil.which("espeak") or shutil.which("espeak-ng"):
            return EspeakTTS(self.config.get("tts_voice", "pl"))
        return None

    def speak(self, text: str):
        if self.tts and self.config.get("auto_tts", True):
            threading.Thread(target=self.tts.speak, args=(text[:200],), daemon=True).start()

    def transcribe(self, audio_path: str) -> str:
        if not self.stt:
            return ""
        cprint(Colors.YELLOW, "üîÑ Rozpoznawanie...", end=" ")
        text = self.stt.transcribe(audio_path)
        if text:
            cprint(Colors.GREEN, f"‚úÖ \"{text}\"")
        else:
            cprint(Colors.RED, "‚ùå Nie rozpoznano")
        return text

    def listen(self, stt_file: Optional[str] = None) -> str:
        audio_path = stt_file or record_audio(self.config.get("timeout", 5))
        if not audio_path:
            return ""
        return self.transcribe(audio_path)

    def run_command(self, cmd: str):
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=60)
            return result.stdout + result.stderr, result.returncode
        except subprocess.TimeoutExpired:
            return "‚è∞ Timeout (60s)", 124
        except Exception as e:
            return f"‚ùå Error: {e}", 1

    def run(self):
        PS1 = f"{Colors.GREEN}üîä stts(py)>{Colors.NC} "
        cprint(Colors.BOLD + Colors.CYAN, "\nSTTS (python) - Voice Shell\n")
        print("Komendy: ENTER=STT, 'exit'=wyj≈õcie, 'setup'=konfiguracja")

        while True:
            try:
                cmd = input(PS1).strip()
                if cmd in ["exit", "quit", "q"]:
                    break
                if cmd == "setup":
                    self.config = interactive_setup()
                    self.stt = self._init_stt()
                    self.tts = self._init_tts()
                    continue
                if not cmd:
                    cmd = self.listen()
                    if not cmd:
                        continue

                cprint(Colors.BLUE, f"‚ñ∂Ô∏è  {cmd}")
                output, code = self.run_command(cmd)
                if output.strip():
                    print(output)

                lines = [l.strip() for l in output.splitlines() if l.strip()]
                if lines:
                    last = lines[-1]
                    if last != cmd and len(last) > 3:
                        cprint(Colors.MAGENTA, f"üì¢ {last[:80]}")
                        self.speak(last)

                if code != 0:
                    cprint(Colors.RED, f"‚ùå Exit code: {code}")
            except KeyboardInterrupt:
                print()
                continue
            except EOFError:
                break


def parse_args(argv: List[str]):
    stt_file = None
    stt_only = False
    setup = False
    help_ = False
    rest: List[str] = []

    it = iter(argv)
    for a in it:
        if a == "--stt-file":
            stt_file = next(it, None)
        elif a == "--stt-only":
            stt_only = True
        elif a == "--setup":
            setup = True
        elif a in ("--help", "-h"):
            help_ = True
        else:
            rest.append(a)
    return stt_file, stt_only, setup, help_, rest


def main():
    config = load_config()
    stt_file, stt_only, setup, help_, rest = parse_args(sys.argv[1:])

    if help_:
        print(__doc__)
        return 0

    if setup or (config.get("stt_provider") is None and config.get("tts_provider") is None and not rest and not stt_file):
        config = interactive_setup()

    shell = VoiceShell(config)

    if stt_file:
        text = shell.listen(stt_file=stt_file)
        if stt_only:
            print(text)
            return 0 if text else 1
        if text:
            out, code = shell.run_command(text)
            if out.strip():
                print(out)
            return code
        return 1

    if not rest:
        shell.run()
        return 0

    cmd = " ".join(rest)
    out, code = shell.run_command(cmd)
    if out.strip():
        print(out)
    lines = [l.strip() for l in out.splitlines() if l.strip()]
    if lines and shell.tts and config.get("auto_tts", True):
        shell.tts.speak(lines[-1][:200])
    return code


if __name__ == "__main__":
    raise SystemExit(main())
