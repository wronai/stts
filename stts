#!/usr/bin/env python3
"""
stts - Universal STT/TTS Shell Wrapper
Cross-platform voice shell with automatic model download and hardware detection.

Usage:
    stts                    # Interactive voice shell
    stts --setup            # Configure STT/TTS providers
    stts [command] [args]   # Run command with voice output
"""

import os
import sys
import json
import subprocess
import platform
import shutil
import urllib.request
import tarfile
import zipfile
import tempfile
import threading
import readline
import atexit
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, Callable, List, Tuple, Dict, Any

__version__ = "0.0.0"
try:
    __version__ = (Path(__file__).resolve().parent / "VERSION").read_text(encoding="utf-8").strip()
except Exception:
    pass

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CONFIG_DIR = Path.home() / ".config" / "stts"
CONFIG_FILE = CONFIG_DIR / "config.json"
MODELS_DIR = CONFIG_DIR / "models"
HISTORY_FILE = CONFIG_DIR / "history"

DEFAULT_CONFIG = {
    "stt_provider": None,
    "tts_provider": None,
    "stt_model": None,
    "tts_voice": "pl",
    "language": "pl",
    "timeout": 5,
    "auto_tts": True,
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COLORS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[0;33m'
    BLUE = '\033[0;34m'
    MAGENTA = '\033[0;35m'
    CYAN = '\033[0;36m'
    BOLD = '\033[1m'
    NC = '\033[0m'

def cprint(color: str, text: str, end='\n'):
    print(f"{color}{text}{Colors.NC}", end=end, flush=True)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SYSTEM DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class SystemInfo:
    os_name: str
    os_version: str
    arch: str
    cpu_cores: int
    ram_gb: float
    gpu_name: Optional[str]
    gpu_vram_gb: Optional[float]
    is_rpi: bool
    has_mic: bool

def detect_system() -> SystemInfo:
    """Detect system hardware and capabilities."""
    os_name = platform.system().lower()
    os_version = platform.release()
    arch = platform.machine()
    cpu_cores = os.cpu_count() or 1
    
    # RAM detection
    ram_gb = 4.0  # default
    try:
        if os_name == "linux":
            with open("/proc/meminfo") as f:
                for line in f:
                    if line.startswith("MemTotal:"):
                        ram_kb = int(line.split()[1])
                        ram_gb = ram_kb / 1024 / 1024
                        break
        elif os_name == "darwin":
            result = subprocess.run(["sysctl", "-n", "hw.memsize"], capture_output=True, text=True)
            ram_gb = int(result.stdout.strip()) / 1024 / 1024 / 1024
        elif os_name == "windows":
            import ctypes
            kernel32 = ctypes.windll.kernel32
            c_ulong = ctypes.c_ulong
            class MEMORYSTATUS(ctypes.Structure):
                _fields_ = [
                    ('dwLength', c_ulong),
                    ('dwMemoryLoad', c_ulong),
                    ('dwTotalPhys', c_ulong),
                    ('dwAvailPhys', c_ulong),
                    ('dwTotalPageFile', c_ulong),
                    ('dwAvailPageFile', c_ulong),
                    ('dwTotalVirtual', c_ulong),
                    ('dwAvailVirtual', c_ulong),
                ]
            memstatus = MEMORYSTATUS()
            memstatus.dwLength = ctypes.sizeof(MEMORYSTATUS)
            kernel32.GlobalMemoryStatus(ctypes.byref(memstatus))
            ram_gb = memstatus.dwTotalPhys / 1024 / 1024 / 1024
    except:
        pass
    
    # GPU detection
    gpu_name = None
    gpu_vram_gb = None
    try:
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=name,memory.total", "--format=csv,noheader,nounits"],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0:
            parts = result.stdout.strip().split(", ")
            gpu_name = parts[0]
            gpu_vram_gb = float(parts[1]) / 1024 if len(parts) > 1 else None
    except:
        pass
    
    # Raspberry Pi detection
    is_rpi = False
    try:
        if os_name == "linux" and Path("/proc/device-tree/model").exists():
            model = Path("/proc/device-tree/model").read_text()
            is_rpi = "raspberry" in model.lower()
    except:
        pass
    
    # Microphone detection
    has_mic = False
    try:
        if os_name == "linux":
            result = subprocess.run(["arecord", "-l"], capture_output=True, text=True)
            has_mic = "card" in result.stdout.lower()
        elif os_name == "darwin":
            has_mic = True  # macOS usually has mic
        elif os_name == "windows":
            has_mic = True  # Windows usually has mic
    except:
        pass
    
    return SystemInfo(
        os_name=os_name,
        os_version=os_version,
        arch=arch,
        cpu_cores=cpu_cores,
        ram_gb=round(ram_gb, 1),
        gpu_name=gpu_name,
        gpu_vram_gb=round(gpu_vram_gb, 1) if gpu_vram_gb else None,
        is_rpi=is_rpi,
        has_mic=has_mic
    )

def print_system_info(info: SystemInfo):
    """Print system information."""
    cprint(Colors.CYAN, "\nâ•â•â• SYSTEM INFO â•â•â•")
    print(f"  OS:        {info.os_name} {info.os_version}")
    print(f"  Arch:      {info.arch}")
    print(f"  CPU:       {info.cpu_cores} cores")
    print(f"  RAM:       {info.ram_gb} GB")
    if info.gpu_name:
        print(f"  GPU:       {info.gpu_name} ({info.gpu_vram_gb} GB VRAM)")
    else:
        print(f"  GPU:       None detected (CPU only)")
    print(f"  RPi:       {'Yes' if info.is_rpi else 'No'}")
    print(f"  Mic:       {'Yes' if info.has_mic else 'No (install alsa-utils)'}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STT PROVIDERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STT_PROVIDERS = {}

def register_stt(name: str):
    def decorator(cls):
        STT_PROVIDERS[name] = cls
        return cls
    return decorator

class STTProvider:
    name: str = "base"
    description: str = "Base STT provider"
    min_ram_gb: float = 0.5
    min_vram_gb: Optional[float] = None
    models: List[Tuple[str, str, float]] = []  # (name, url, size_gb)
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        return False, "Not implemented"
    
    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        return False
    
    @classmethod
    def get_recommended_model(cls, info: SystemInfo) -> Optional[str]:
        return None
    
    def __init__(self, model: Optional[str] = None, language: str = "pl"):
        self.model = model
        self.language = language
    
    def transcribe(self, audio_path: str) -> str:
        raise NotImplementedError

@register_stt("whisper_cpp")
class WhisperCppSTT(STTProvider):
    name = "whisper.cpp"
    description = "Offline, fast, CPU-optimized Whisper (recommended)"
    min_ram_gb = 1.0
    models = [
        ("tiny", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin", 0.08),
        ("base", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-base.bin", 0.15),
        ("small", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-small.bin", 0.5),
        ("medium", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-medium.bin", 1.5),
        ("large", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-large-v3.bin", 3.0),
    ]
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        if shutil.which("whisper-cpp") or shutil.which("main"):
            return True, "whisper.cpp found"
        whisper_bin = MODELS_DIR / "whisper.cpp" / "main"
        if whisper_bin.exists():
            return True, f"whisper.cpp at {whisper_bin}"
        return False, "whisper.cpp not installed"
    
    @classmethod
    def get_recommended_model(cls, info: SystemInfo) -> str:
        if info.ram_gb < 2:
            return "tiny"
        elif info.ram_gb < 4:
            return "base"
        elif info.ram_gb < 8:
            return "small"
        elif info.ram_gb < 16:
            return "medium"
        return "large"
    
    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        """Install whisper.cpp from source."""
        cprint(Colors.YELLOW, "ğŸ“¦ Installing whisper.cpp...")
        
        whisper_dir = MODELS_DIR / "whisper.cpp"
        whisper_dir.mkdir(parents=True, exist_ok=True)
        
        try:
            # Clone
            if not (whisper_dir / "Makefile").exists():
                subprocess.run(
                    ["git", "clone", "https://github.com/ggerganov/whisper.cpp", str(whisper_dir)],
                    check=True
                )
            
            # Build
            subprocess.run(["make", "-j"], cwd=whisper_dir, check=True)
            
            cprint(Colors.GREEN, "âœ… whisper.cpp installed!")
            return True
        except Exception as e:
            cprint(Colors.RED, f"âŒ Installation failed: {e}")
            return False
    
    @classmethod
    def download_model(cls, model_name: str) -> Optional[Path]:
        """Download whisper model."""
        model_info = next((m for m in cls.models if m[0] == model_name), None)
        if not model_info:
            cprint(Colors.RED, f"âŒ Unknown model: {model_name}")
            return None
        
        name, url, size = model_info
        model_path = MODELS_DIR / "whisper.cpp" / f"ggml-{name}.bin"
        
        if model_path.exists():
            cprint(Colors.GREEN, f"âœ… Model {name} already downloaded")
            return model_path
        
        cprint(Colors.YELLOW, f"ğŸ“¥ Downloading {name} model ({size} GB)...")
        model_path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            urllib.request.urlretrieve(url, model_path, _download_progress)
            print()
            cprint(Colors.GREEN, f"âœ… Model {name} downloaded!")
            return model_path
        except Exception as e:
            cprint(Colors.RED, f"âŒ Download failed: {e}")
            return None
    
    def transcribe(self, audio_path: str) -> str:
        # Find whisper binary
        whisper_bin = shutil.which("whisper-cpp") or shutil.which("main")
        if not whisper_bin:
            whisper_bin = str(MODELS_DIR / "whisper.cpp" / "main")
        
        # Find model
        model_path = MODELS_DIR / "whisper.cpp" / f"ggml-{self.model or 'base'}.bin"
        if not model_path.exists():
            model_path = self.download_model(self.model or "base")
        
        if not model_path:
            return ""
        
        try:
            result = subprocess.run(
                [whisper_bin, "-m", str(model_path), "-l", self.language, "-f", audio_path, "-nt"],
                capture_output=True, text=True, timeout=60
            )
            return result.stdout.strip()
        except Exception as e:
            cprint(Colors.RED, f"âŒ Transcription error: {e}")
            return ""

@register_stt("faster_whisper")
class FasterWhisperSTT(STTProvider):
    name = "faster-whisper"
    description = "Python Whisper with CTranslate2 (GPU optimized)"
    min_ram_gb = 2.0
    min_vram_gb = 2.0
    models = [
        ("tiny", "", 0.08),
        ("base", "", 0.15),
        ("small", "", 0.5),
        ("medium", "", 1.5),
        ("large-v3", "", 3.0),
    ]
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        try:
            import faster_whisper
            return True, "faster-whisper installed"
        except ImportError:
            return False, "pip install faster-whisper"
    
    @classmethod
    def get_recommended_model(cls, info: SystemInfo) -> str:
        if info.gpu_vram_gb:
            if info.gpu_vram_gb >= 8:
                return "large-v3"
            elif info.gpu_vram_gb >= 4:
                return "medium"
            return "small"
        # CPU fallback
        if info.ram_gb < 4:
            return "tiny"
        elif info.ram_gb < 8:
            return "base"
        return "small"
    
    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        cprint(Colors.YELLOW, "ğŸ“¦ Installing faster-whisper...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", "faster-whisper"], check=True)
            cprint(Colors.GREEN, "âœ… faster-whisper installed!")
            return True
        except:
            cprint(Colors.RED, "âŒ Installation failed")
            return False
    
    def __init__(self, model: Optional[str] = None, language: str = "pl"):
        super().__init__(model, language)
        self._model = None
    
    def transcribe(self, audio_path: str) -> str:
        try:
            from faster_whisper import WhisperModel
            
            if self._model is None:
                model_name = self.model or "base"
                cprint(Colors.YELLOW, f"ğŸ”„ Loading {model_name} model...")
                self._model = WhisperModel(model_name, device="auto", compute_type="auto")
            
            segments, _ = self._model.transcribe(audio_path, language=self.language)
            return " ".join(s.text for s in segments).strip()
        except Exception as e:
            cprint(Colors.RED, f"âŒ Transcription error: {e}")
            return ""

@register_stt("vosk")
class VoskSTT(STTProvider):
    name = "vosk"
    description = "Lightweight offline STT (good for RPi)"
    min_ram_gb = 0.5
    models = [
        ("small-pl", "https://alphacephei.com/vosk/models/vosk-model-small-pl-0.22.zip", 0.05),
        ("pl", "https://alphacephei.com/vosk/models/vosk-model-pl-0.22.zip", 1.0),
    ]
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        try:
            import vosk
            return True, "vosk installed"
        except ImportError:
            return False, "pip install vosk"
    
    @classmethod
    def get_recommended_model(cls, info: SystemInfo) -> str:
        return "small-pl" if info.ram_gb < 2 or info.is_rpi else "pl"
    
    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        cprint(Colors.YELLOW, "ğŸ“¦ Installing vosk...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", "vosk"], check=True)
            cprint(Colors.GREEN, "âœ… vosk installed!")
            return True
        except:
            cprint(Colors.RED, "âŒ Installation failed")
            return False
    
    @classmethod
    def download_model(cls, model_name: str) -> Optional[Path]:
        model_info = next((m for m in cls.models if m[0] == model_name), None)
        if not model_info:
            return None
        
        name, url, _ = model_info
        model_dir = MODELS_DIR / "vosk" / f"vosk-model-{name}"
        
        if model_dir.exists():
            return model_dir
        
        cprint(Colors.YELLOW, f"ğŸ“¥ Downloading vosk {name} model...")
        model_dir.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            zip_path = model_dir.parent / f"{name}.zip"
            urllib.request.urlretrieve(url, zip_path, _download_progress)
            print()
            
            with zipfile.ZipFile(zip_path, 'r') as z:
                z.extractall(model_dir.parent)
            zip_path.unlink()
            
            cprint(Colors.GREEN, f"âœ… Model {name} downloaded!")
            return model_dir
        except Exception as e:
            cprint(Colors.RED, f"âŒ Download failed: {e}")
            return None
    
    def __init__(self, model: Optional[str] = None, language: str = "pl"):
        super().__init__(model, language)
        self._model = None
    
    def transcribe(self, audio_path: str) -> str:
        try:
            import vosk
            import wave
            import json as json_module
            
            model_path = self.download_model(self.model or "small-pl")
            if not model_path:
                return ""
            
            if self._model is None:
                vosk.SetLogLevel(-1)
                self._model = vosk.Model(str(model_path))
            
            with wave.open(audio_path, "rb") as wf:
                rec = vosk.KaldiRecognizer(self._model, wf.getframerate())
                while True:
                    data = wf.readframes(4000)
                    if len(data) == 0:
                        break
                    rec.AcceptWaveform(data)
                
                result = json_module.loads(rec.FinalResult())
                return result.get("text", "")
        except Exception as e:
            cprint(Colors.RED, f"âŒ Transcription error: {e}")
            return ""

@register_stt("google")
class GoogleSTT(STTProvider):
    name = "google"
    description = "Google Speech API (online, free tier)"
    min_ram_gb = 0.5
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        try:
            import speech_recognition
            return True, "speech_recognition installed"
        except ImportError:
            return False, "pip install SpeechRecognition"
    
    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        cprint(Colors.YELLOW, "ğŸ“¦ Installing speech_recognition...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", "SpeechRecognition"], check=True)
            cprint(Colors.GREEN, "âœ… speech_recognition installed!")
            return True
        except:
            cprint(Colors.RED, "âŒ Installation failed")
            return False
    
    def transcribe(self, audio_path: str) -> str:
        try:
            import speech_recognition as sr
            r = sr.Recognizer()
            with sr.AudioFile(audio_path) as source:
                audio = r.record(source)
            return r.recognize_google(audio, language=f"{self.language}-PL")
        except Exception as e:
            cprint(Colors.RED, f"âŒ Transcription error: {e}")
            return ""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TTS PROVIDERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TTS_PROVIDERS = {}

def register_tts(name: str):
    def decorator(cls):
        TTS_PROVIDERS[name] = cls
        return cls
    return decorator

class TTSProvider:
    name: str = "base"
    description: str = "Base TTS provider"
    min_ram_gb: float = 0.1
    voices: List[str] = []
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        return False, "Not implemented"
    
    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        return False
    
    def __init__(self, voice: str = "pl"):
        self.voice = voice
    
    def speak(self, text: str) -> None:
        raise NotImplementedError

@register_tts("espeak")
class EspeakTTS(TTSProvider):
    name = "espeak"
    description = "Basic offline TTS (fast, low quality)"
    min_ram_gb = 0.1
    voices = ["pl", "en", "de", "fr", "es"]
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        if shutil.which("espeak") or shutil.which("espeak-ng"):
            return True, "espeak found"
        return False, "apt install espeak / espeak-ng"
    
    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        if info.os_name == "linux":
            cprint(Colors.YELLOW, "ğŸ“¦ Installing espeak...")
            try:
                subprocess.run(["sudo", "apt", "install", "-y", "espeak"], check=True)
                return True
            except:
                pass
        cprint(Colors.RED, "âŒ Install manually: sudo apt install espeak")
        return False
    
    def speak(self, text: str) -> None:
        cmd = shutil.which("espeak-ng") or shutil.which("espeak")
        if cmd:
            subprocess.run([cmd, "-v", self.voice, "-s", "160", text], 
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

@register_tts("piper")
class PiperTTS(TTSProvider):
    name = "piper"
    description = "High-quality offline TTS (neural, recommended)"
    min_ram_gb = 0.5
    voices = [
        ("pl_PL-gosia-medium", "https://huggingface.co/rhasspy/piper-voices/resolve/main/pl/pl_PL/gosia/medium/pl_PL-gosia-medium.onnx"),
        ("pl_PL-darkman-medium", "https://huggingface.co/rhasspy/piper-voices/resolve/main/pl/pl_PL/darkman/medium/pl_PL-darkman-medium.onnx"),
        ("en_US-lessac-medium", "https://huggingface.co/rhasspy/piper-voices/resolve/main/en/en_US/lessac/medium/en_US-lessac-medium.onnx"),
    ]
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        if shutil.which("piper"):
            return True, "piper found"
        piper_bin = MODELS_DIR / "piper" / "piper"
        if piper_bin.exists():
            return True, f"piper at {piper_bin}"
        return False, "piper not installed"
    
    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        """Download piper binary."""
        cprint(Colors.YELLOW, "ğŸ“¦ Installing piper...")
        
        piper_dir = MODELS_DIR / "piper"
        piper_dir.mkdir(parents=True, exist_ok=True)
        
        # Determine platform
        if info.os_name == "linux":
            if info.arch in ["x86_64", "amd64"]:
                url = "https://github.com/rhasspy/piper/releases/download/v1.2.0/piper_amd64.tar.gz"
            elif info.arch in ["aarch64", "arm64"]:
                url = "https://github.com/rhasspy/piper/releases/download/v1.2.0/piper_arm64.tar.gz"
            elif "arm" in info.arch:
                url = "https://github.com/rhasspy/piper/releases/download/v1.2.0/piper_armv7.tar.gz"
            else:
                cprint(Colors.RED, f"âŒ Unsupported arch: {info.arch}")
                return False
        elif info.os_name == "darwin":
            url = "https://github.com/rhasspy/piper/releases/download/v1.2.0/piper_macos_x64.tar.gz"
        else:
            cprint(Colors.RED, "âŒ Piper not available for Windows, use espeak")
            return False
        
        try:
            tar_path = piper_dir / "piper.tar.gz"
            cprint(Colors.YELLOW, f"ğŸ“¥ Downloading piper...")
            urllib.request.urlretrieve(url, tar_path, _download_progress)
            print()
            
            with tarfile.open(tar_path, "r:gz") as tar:
                tar.extractall(piper_dir)
            tar_path.unlink()
            
            # Make executable
            piper_bin = piper_dir / "piper" / "piper"
            if piper_bin.exists():
                piper_bin.chmod(0o755)
            
            cprint(Colors.GREEN, "âœ… piper installed!")
            return True
        except Exception as e:
            cprint(Colors.RED, f"âŒ Installation failed: {e}")
            return False
    
    @classmethod
    def download_voice(cls, voice_name: str) -> Optional[Path]:
        voice_info = next((v for v in cls.voices if v[0] == voice_name), None)
        if not voice_info:
            # Try default Polish voice
            voice_info = cls.voices[0]
        
        name, url = voice_info
        voice_path = MODELS_DIR / "piper" / "voices" / f"{name}.onnx"
        json_path = voice_path.with_suffix(".onnx.json")
        
        if voice_path.exists():
            return voice_path
        
        cprint(Colors.YELLOW, f"ğŸ“¥ Downloading voice {name}...")
        voice_path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            urllib.request.urlretrieve(url, voice_path, _download_progress)
            urllib.request.urlretrieve(url + ".json", json_path)
            print()
            cprint(Colors.GREEN, f"âœ… Voice {name} downloaded!")
            return voice_path
        except Exception as e:
            cprint(Colors.RED, f"âŒ Download failed: {e}")
            return None
    
    def speak(self, text: str) -> None:
        piper_bin = shutil.which("piper")
        if not piper_bin:
            piper_bin = str(MODELS_DIR / "piper" / "piper" / "piper")
        
        # Find voice
        voice_name = f"pl_PL-gosia-medium" if self.voice == "pl" else f"en_US-lessac-medium"
        voice_path = self.download_voice(voice_name)
        
        if not voice_path:
            # Fallback to espeak
            EspeakTTS(self.voice).speak(text)
            return
        
        try:
            proc = subprocess.Popen(
                [piper_bin, "--model", str(voice_path), "--output-raw"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL
            )
            
            # Play audio
            aplay = subprocess.Popen(
                ["aplay", "-r", "22050", "-f", "S16_LE", "-t", "raw", "-"],
                stdin=proc.stdout,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            proc.stdin.write(text.encode())
            proc.stdin.close()
            aplay.wait()
        except Exception as e:
            cprint(Colors.RED, f"âŒ TTS error: {e}")
            EspeakTTS(self.voice).speak(text)

@register_tts("system")
class SystemTTS(TTSProvider):
    name = "system"
    description = "System TTS (macOS say, Windows SAPI)"
    
    @classmethod
    def is_available(cls, info: SystemInfo) -> Tuple[bool, str]:
        if info.os_name == "darwin":
            return True, "macOS say"
        elif info.os_name == "windows":
            return True, "Windows SAPI"
        return False, "Linux: use espeak or piper"
    
    def speak(self, text: str) -> None:
        info = detect_system()
        if info.os_name == "darwin":
            subprocess.run(["say", "-v", "Zosia" if self.voice == "pl" else "Samantha", text],
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif info.os_name == "windows":
            ps_cmd = f'Add-Type -AssemblyName System.Speech; $s=New-Object System.Speech.Synthesis.SpeechSynthesizer; $s.Speak("{text}")'
            subprocess.run(["powershell", "-c", ps_cmd], 
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AUDIO RECORDING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def record_audio(duration: int = 5, output_path: str = "/tmp/stts_audio.wav") -> str:
    """Record audio from microphone."""
    info = detect_system()
    
    cprint(Colors.GREEN, f"ğŸ¤ MÃ³w ({duration}s)...", end=" ")
    
    try:
        if info.os_name == "linux":
            subprocess.run(
                ["arecord", "-d", str(duration), "-f", "cd", "-t", "wav", output_path],
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=duration + 2
            )
        elif info.os_name == "darwin":
            subprocess.run(
                ["rec", "-r", "16000", "-c", "1", output_path, "trim", "0", str(duration)],
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=duration + 2
            )
        else:
            # Windows - try sounddevice
            try:
                import sounddevice as sd
                import scipy.io.wavfile as wav
                import numpy as np
                audio = sd.rec(int(duration * 16000), samplerate=16000, channels=1, dtype='int16')
                sd.wait()
                wav.write(output_path, 16000, audio)
            except ImportError:
                cprint(Colors.RED, "âŒ Windows: pip install sounddevice scipy")
                return ""
        
        print("âœ…")
        return output_path
    except Exception as e:
        cprint(Colors.RED, f"âŒ Recording failed: {e}")
        return ""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def load_config() -> dict:
    """Load configuration."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    if CONFIG_FILE.exists():
        try:
            return json.loads(CONFIG_FILE.read_text())
        except:
            pass
    return DEFAULT_CONFIG.copy()

def save_config(config: dict) -> None:
    """Save configuration."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_FILE.write_text(json.dumps(config, indent=2))

def _download_progress(count, block_size, total_size):
    """Show download progress."""
    percent = int(count * block_size * 100 / total_size) if total_size > 0 else 0
    print(f"\r  Progress: {percent}%", end="", flush=True)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTERACTIVE SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def interactive_setup() -> dict:
    """Interactive setup wizard."""
    config = load_config()
    info = detect_system()
    
    cprint(Colors.BOLD + Colors.CYAN, """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ™ï¸  STTS - Setup Wizard                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
    
    print_system_info(info)
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STT Selection
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cprint(Colors.CYAN, "\nâ•â•â• STT (Speech-to-Text) â•â•â•")
    
    print("\nDostÄ™pne providery:")
    stt_options = []
    for i, (name, cls) in enumerate(STT_PROVIDERS.items(), 1):
        available, reason = cls.is_available(info)
        status = f"{Colors.GREEN}âœ…" if available else f"{Colors.YELLOW}âš ï¸"
        rec_model = cls.get_recommended_model(info) if hasattr(cls, 'get_recommended_model') else None
        
        # Resource requirements
        req = f"RAMâ‰¥{cls.min_ram_gb}GB"
        if hasattr(cls, 'min_vram_gb') and cls.min_vram_gb:
            req += f", VRAMâ‰¥{cls.min_vram_gb}GB"
        
        can_run = info.ram_gb >= cls.min_ram_gb
        if hasattr(cls, 'min_vram_gb') and cls.min_vram_gb:
            can_run = can_run and (info.gpu_vram_gb and info.gpu_vram_gb >= cls.min_vram_gb)
        
        run_status = f"{Colors.GREEN}(OK)" if can_run else f"{Colors.RED}(za sÅ‚aby sprzÄ™t)"
        
        print(f"  {status} {i}. {cls.name}{Colors.NC} - {cls.description}")
        print(f"      Wymagania: {req} {run_status}{Colors.NC}")
        print(f"      Status: {reason}")
        if rec_model:
            print(f"      Rekomendowany model: {rec_model}")
        
        stt_options.append((name, cls, can_run))
    
    print()
    while True:
        choice = input(f"Wybierz STT (1-{len(stt_options)}, ENTER=skip): ").strip()
        if not choice:
            break
        try:
            idx = int(choice) - 1
            if 0 <= idx < len(stt_options):
                name, cls, can_run = stt_options[idx]
                if not can_run:
                    cprint(Colors.YELLOW, "âš ï¸  Ten provider moÅ¼e nie dziaÅ‚aÄ‡ na tym sprzÄ™cie. KontynuowaÄ‡? (y/n)")
                    if input().lower() != 'y':
                        continue
                
                available, _ = cls.is_available(info)
                if not available:
                    cprint(Colors.YELLOW, f"ğŸ“¦ {cls.name} nie jest zainstalowany. ZainstalowaÄ‡? (y/n)")
                    if input().lower() == 'y':
                        cls.install(info)
                
                config["stt_provider"] = name
                
                # Model selection
                if hasattr(cls, 'models') and cls.models:
                    rec_model = cls.get_recommended_model(info)
                    print(f"\nDostÄ™pne modele (rekomendowany: {rec_model}):")
                    for j, (mname, _, msize) in enumerate(cls.models, 1):
                        rec_mark = " â† rekomendowany" if mname == rec_model else ""
                        print(f"  {j}. {mname} ({msize} GB){rec_mark}")
                    
                    model_choice = input(f"Wybierz model (1-{len(cls.models)}, ENTER={rec_model}): ").strip()
                    if model_choice:
                        try:
                            midx = int(model_choice) - 1
                            config["stt_model"] = cls.models[midx][0]
                        except:
                            config["stt_model"] = rec_model
                    else:
                        config["stt_model"] = rec_model
                    
                    # Download model
                    if hasattr(cls, 'download_model'):
                        cprint(Colors.YELLOW, f"ğŸ“¥ PobraÄ‡ model {config['stt_model']} teraz? (y/n)")
                        if input().lower() == 'y':
                            cls.download_model(config["stt_model"])
                
                break
        except ValueError:
            pass
        cprint(Colors.RED, "âŒ NieprawidÅ‚owy wybÃ³r")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # TTS Selection
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cprint(Colors.CYAN, "\nâ•â•â• TTS (Text-to-Speech) â•â•â•")
    
    print("\nDostÄ™pne providery:")
    tts_options = []
    for i, (name, cls) in enumerate(TTS_PROVIDERS.items(), 1):
        available, reason = cls.is_available(info)
        status = f"{Colors.GREEN}âœ…" if available else f"{Colors.YELLOW}âš ï¸"
        
        req = f"RAMâ‰¥{cls.min_ram_gb}GB"
        can_run = info.ram_gb >= cls.min_ram_gb
        run_status = f"{Colors.GREEN}(OK)" if can_run else f"{Colors.RED}(za sÅ‚aby sprzÄ™t)"
        
        print(f"  {status} {i}. {cls.name}{Colors.NC} - {cls.description}")
        print(f"      Wymagania: {req} {run_status}{Colors.NC}")
        print(f"      Status: {reason}")
        
        tts_options.append((name, cls, can_run))
    
    print()
    while True:
        choice = input(f"Wybierz TTS (1-{len(tts_options)}, ENTER=skip): ").strip()
        if not choice:
            break
        try:
            idx = int(choice) - 1
            if 0 <= idx < len(tts_options):
                name, cls, can_run = tts_options[idx]
                
                available, _ = cls.is_available(info)
                if not available:
                    cprint(Colors.YELLOW, f"ğŸ“¦ {cls.name} nie jest zainstalowany. ZainstalowaÄ‡? (y/n)")
                    if input().lower() == 'y':
                        cls.install(info)
                
                config["tts_provider"] = name
                break
        except ValueError:
            pass
        cprint(Colors.RED, "âŒ NieprawidÅ‚owy wybÃ³r")
    
    # Save config
    save_config(config)
    cprint(Colors.GREEN, f"\nâœ… Konfiguracja zapisana do {CONFIG_FILE}")
    
    return config

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VOICE SHELL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class VoiceShell:
    def __init__(self, config: dict):
        self.config = config
        self.info = detect_system()
        self.stt = self._init_stt()
        self.tts = self._init_tts()
        
        # History
        HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
        if HISTORY_FILE.exists():
            readline.read_history_file(str(HISTORY_FILE))
        atexit.register(lambda: readline.write_history_file(str(HISTORY_FILE)))
    
    def _init_stt(self) -> Optional[STTProvider]:
        provider = self.config.get("stt_provider")
        if provider and provider in STT_PROVIDERS:
            cls = STT_PROVIDERS[provider]
            available, _ = cls.is_available(self.info)
            if available:
                return cls(
                    model=self.config.get("stt_model"),
                    language=self.config.get("language", "pl")
                )
        return None
    
    def _init_tts(self) -> Optional[TTSProvider]:
        provider = self.config.get("tts_provider")
        if provider and provider in TTS_PROVIDERS:
            cls = TTS_PROVIDERS[provider]
            available, _ = cls.is_available(self.info)
            if available:
                return cls(voice=self.config.get("tts_voice", "pl"))
        
        # Fallback to espeak
        if shutil.which("espeak") or shutil.which("espeak-ng"):
            return EspeakTTS(self.config.get("tts_voice", "pl"))
        return None
    
    def speak(self, text: str) -> None:
        """Speak text using TTS."""
        if self.tts and self.config.get("auto_tts", True):
            # Run in background
            threading.Thread(target=self.tts.speak, args=(text[:200],), daemon=True).start()
    
    def listen(self) -> str:
        """Listen and transcribe speech."""
        if not self.stt:
            cprint(Colors.YELLOW, "âš ï¸  STT nie skonfigurowany. Uruchom: stts --setup")
            return ""
        
        audio_path = record_audio(self.config.get("timeout", 5))
        if not audio_path:
            return ""
        
        cprint(Colors.YELLOW, "ğŸ”„ Rozpoznawanie...", end=" ")
        text = self.stt.transcribe(audio_path)
        
        if text:
            cprint(Colors.GREEN, f"âœ… \"{text}\"")
        else:
            cprint(Colors.RED, "âŒ Nie rozpoznano")
        
        return text
    
    def run_command(self, cmd: str) -> Tuple[str, int]:
        """Run command and return output."""
        try:
            result = subprocess.run(
                cmd, shell=True, capture_output=True, text=True, timeout=60
            )
            output = result.stdout + result.stderr
            return output, result.returncode
        except subprocess.TimeoutExpired:
            return "â° Timeout (60s)", 124
        except Exception as e:
            return f"âŒ Error: {e}", 1
    
    def run(self) -> None:
        """Main shell loop."""
        PS1 = f"{Colors.GREEN}ğŸ”Š stts>{Colors.NC} "
        
        cprint(Colors.BOLD + Colors.CYAN, """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ™ï¸  STTS - Voice Shell                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        
        if self.stt:
            cprint(Colors.GREEN, f"  STT: {self.stt.name} (model: {self.stt.model or 'default'})")
        else:
            cprint(Colors.YELLOW, "  STT: nie skonfigurowany (uruchom: stts --setup)")
        
        if self.tts:
            cprint(Colors.GREEN, f"  TTS: {self.tts.name}")
        else:
            cprint(Colors.YELLOW, "  TTS: nie skonfigurowany")
        
        print("\n  Komendy: ENTER=STT, 'exit'=wyjÅ›cie, 'setup'=konfiguracja\n")
        
        while True:
            try:
                cmd = input(PS1).strip()
                
                # Special commands
                if cmd in ["exit", "quit", "q"]:
                    break
                elif cmd == "setup":
                    self.config = interactive_setup()
                    self.stt = self._init_stt()
                    self.tts = self._init_tts()
                    continue
                
                # Empty = STT
                if not cmd:
                    cmd = self.listen()
                    if not cmd:
                        continue
                
                # Run command
                cprint(Colors.BLUE, f"â–¶ï¸  {cmd}")
                output, code = self.run_command(cmd)
                
                if output.strip():
                    print(output)
                
                # TTS last line
                lines = [l.strip() for l in output.splitlines() if l.strip()]
                if lines:
                    last_line = lines[-1]
                    if last_line != cmd and len(last_line) > 3:
                        cprint(Colors.MAGENTA, f"ğŸ“¢ {last_line[:80]}")
                        self.speak(last_line)
                
                if code != 0:
                    cprint(Colors.RED, f"âŒ Exit code: {code}")
                
            except KeyboardInterrupt:
                print()
                continue
            except EOFError:
                break
        
        cprint(Colors.CYAN, "\nğŸ‘‹ Do widzenia!")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMMAND WRAPPER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def run_with_voice(args: List[str], config: dict) -> int:
    """Run command with voice output."""
    info = detect_system()
    
    # Initialize TTS
    tts = None
    provider = config.get("tts_provider")
    if provider and provider in TTS_PROVIDERS:
        cls = TTS_PROVIDERS[provider]
        available, _ = cls.is_available(info)
        if available:
            tts = cls(voice=config.get("tts_voice", "pl"))
    
    if not tts and (shutil.which("espeak") or shutil.which("espeak-ng")):
        tts = EspeakTTS(config.get("tts_voice", "pl"))
    
    # Run command
    cmd = " ".join(args)
    cprint(Colors.GREEN, f"ğŸš€ {cmd}")
    
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        output = result.stdout + result.stderr
        
        if output.strip():
            print(output)
        
        # TTS last line
        lines = [l.strip() for l in output.splitlines() if l.strip()]
        if lines and tts:
            last_line = lines[-1]
            cprint(Colors.MAGENTA, f"ğŸ“¢ {last_line[:80]}")
            tts.speak(last_line[:200])
        
        # Ask for voice input
        if config.get("stt_provider"):
            print()
            reply = input("ğŸ¤ GÅ‚osowy input? (y/n): ").strip().lower()
            if reply == 'y':
                shell = VoiceShell(config)
                voice_cmd = shell.listen()
                if voice_cmd:
                    cprint(Colors.GREEN, f"â–¶ï¸  {voice_cmd}")
                    subprocess.run(voice_cmd, shell=True)
        
        return result.returncode
    except Exception as e:
        cprint(Colors.RED, f"âŒ Error: {e}")
        return 1

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    config = load_config()

    if "--version" in sys.argv or "-V" in sys.argv:
        print(__version__)
        return
    
    # First run - setup
    if config.get("stt_provider") is None and config.get("tts_provider") is None:
        if len(sys.argv) == 1 or "--setup" in sys.argv:
            config = interactive_setup()
    elif "--setup" in sys.argv:
        interactive_setup()
        return
    elif "--help" in sys.argv or "-h" in sys.argv:
        print(__doc__)
        print("\nOpcje:")
        print("  --setup    Konfiguracja STT/TTS")
        print("  --version  PokaÅ¼ wersjÄ™")
        print("  --help     Ta pomoc")
        print("\nPrzykÅ‚ady:")
        print("  stts                    # Voice shell")
        print("  stts make build         # Uruchom z gÅ‚osowym output")
        print("  stts python script.py   # Dowolna komenda")
    elif len(sys.argv) == 1:
        # Interactive shell
        shell = VoiceShell(config)
        shell.run()
    else:
        # Command wrapper
        exit(run_with_voice(sys.argv[1:], config))

if __name__ == "__main__":
    main()
