#!/usr/bin/env python3
"""
stts (python) - Universal STT/TTS Shell Wrapper

Usage:
  ./stts                      # Interactive voice shell
  ./stts --setup              # Configure STT/TTS providers
  ./stts [cmd] [args...]      # Run command with voice output

Testing / simulation:
  ./stts --stt-file file.wav --stt-only
  ./stts --stt-file file.wav            # transcribe and execute

Notes:
  - Config stored in ~/.config/stts-python/
"""

import os
import sys
import json
import subprocess
import platform
import shutil
import urllib.request
import tarfile
import zipfile
import threading
import readline
import atexit
import wave
import math
import shlex
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, List, Tuple


def load_dotenv() -> None:
    candidates = []
    try:
        here = Path(__file__).resolve().parent
        candidates.append(Path.cwd() / ".env")
        candidates.append(here / ".env")
        candidates.append(here.parent / ".env")
    except Exception:
        pass

    for p in candidates:
        try:
            if not p.exists() or not p.is_file():
                continue
            for line in p.read_text(encoding="utf-8").splitlines():
                s = line.strip()
                if not s or s.startswith("#"):
                    continue
                if s.lower().startswith("export "):
                    s = s[7:].strip()
                if "=" not in s:
                    continue
                k, v = s.split("=", 1)
                k = k.strip()
                v = v.strip().strip('"').strip("'")
                if not k:
                    continue
                os.environ.setdefault(k, v)
            break
        except Exception:
            continue


load_dotenv()

_CONFIG_DIR_ENV = os.environ.get("STTS_CONFIG_DIR")
CONFIG_DIR = (Path(_CONFIG_DIR_ENV).expanduser() if _CONFIG_DIR_ENV else (Path.home() / ".config" / "stts-python"))
CONFIG_FILE = CONFIG_DIR / "config.json"
MODELS_DIR = CONFIG_DIR / "models"
HISTORY_FILE = CONFIG_DIR / "history"

DEFAULT_CONFIG = {
    "stt_provider": None,
    "tts_provider": None,
    "stt_model": None,
    "tts_voice": "pl",
    "language": "pl",
    "timeout": 5,
    "auto_tts": True,
    "mic_device": None,
    "speaker_device": None,
    "audio_auto_switch": True,
}


def apply_env_overrides(config: dict) -> dict:
    if os.environ.get("STTS_TIMEOUT"):
        try:
            config["timeout"] = int(os.environ["STTS_TIMEOUT"])
        except Exception:
            pass
    if os.environ.get("STTS_LANGUAGE"):
        config["language"] = os.environ["STTS_LANGUAGE"].strip() or config.get("language")
    if os.environ.get("STTS_TTS_VOICE"):
        config["tts_voice"] = os.environ["STTS_TTS_VOICE"].strip() or config.get("tts_voice")
    if os.environ.get("STTS_MIC_DEVICE"):
        v = os.environ["STTS_MIC_DEVICE"].strip()
        config["mic_device"] = None if v in ("0", "auto", "") else v
    if os.environ.get("STTS_SPEAKER_DEVICE"):
        v = os.environ["STTS_SPEAKER_DEVICE"].strip()
        config["speaker_device"] = None if v in ("0", "auto", "") else v
    if os.environ.get("STTS_AUDIO_AUTO_SWITCH"):
        config["audio_auto_switch"] = os.environ["STTS_AUDIO_AUTO_SWITCH"].strip() not in ("0", "false", "no", "n")
    return config

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[0;33m'
    BLUE = '\033[0;34m'
    MAGENTA = '\033[0;35m'
    CYAN = '\033[0;36m'
    BOLD = '\033[1m'
    NC = '\033[0m'


def cprint(color: str, text: str, end: str = "\n"):
    print(f"{color}{text}{Colors.NC}", end=end, flush=True)


def _download_progress(count, block_size, total_size):
    percent = int(count * block_size * 100 / total_size) if total_size > 0 else 0
    print(f"\r  Progress: {percent}%", end="", flush=True)


@dataclass
class SystemInfo:
    os_name: str
    os_version: str
    arch: str
    cpu_cores: int
    ram_gb: float
    gpu_name: Optional[str]
    gpu_vram_gb: Optional[float]
    is_rpi: bool
    has_mic: bool


def detect_system() -> SystemInfo:
    os_name = platform.system().lower()
    os_version = platform.release()
    arch = platform.machine()
    cpu_cores = os.cpu_count() or 1

    ram_gb = 4.0
    try:
        if os_name == "linux":
            with open("/proc/meminfo") as f:
                for line in f:
                    if line.startswith("MemTotal:"):
                        ram_kb = int(line.split()[1])
                        ram_gb = ram_kb / 1024 / 1024
                        break
    except:
        pass

    gpu_name = None
    gpu_vram_gb = None
    try:
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=name,memory.total", "--format=csv,noheader,nounits"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            parts = result.stdout.strip().split(", ")
            gpu_name = parts[0]
            gpu_vram_gb = float(parts[1]) / 1024 if len(parts) > 1 else None
    except:
        pass

    is_rpi = False
    try:
        if os_name == "linux" and Path("/proc/device-tree/model").exists():
            model = Path("/proc/device-tree/model").read_text()
            is_rpi = "raspberry" in model.lower()
    except:
        pass

    has_mic = False
    try:
        if os_name == "linux":
            result = subprocess.run(["arecord", "-l"], capture_output=True, text=True)
            has_mic = "card" in result.stdout.lower()
        else:
            has_mic = True
    except:
        pass

    return SystemInfo(
        os_name=os_name,
        os_version=os_version,
        arch=arch,
        cpu_cores=cpu_cores,
        ram_gb=round(ram_gb, 1),
        gpu_name=gpu_name,
        gpu_vram_gb=round(gpu_vram_gb, 1) if gpu_vram_gb else None,
        is_rpi=is_rpi,
        has_mic=has_mic,
    )


def load_config() -> dict:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    if CONFIG_FILE.exists():
        try:
            cfg = DEFAULT_CONFIG.copy()
            cfg.update(json.loads(CONFIG_FILE.read_text()))
            return apply_env_overrides(cfg)
        except:
            pass
    return apply_env_overrides(DEFAULT_CONFIG.copy())


def save_config(config: dict) -> None:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_FILE.write_text(json.dumps(config, indent=2))


def _run_text(cmd: List[str], timeout: int = 3) -> str:
    try:
        res = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
        return (res.stdout or "") + (res.stderr or "")
    except Exception:
        return ""


def list_capture_devices_linux() -> List[Tuple[str, str]]:
    devices: List[Tuple[str, str]] = []
    out = _run_text(["arecord", "-l"], timeout=3)
    cards = {}
    card = None
    for line in out.splitlines():
        line = line.strip()
        if line.startswith("card ") and ":" in line:
            # card 0: PCH [HDA Intel PCH], device 0: ...
            parts = line.split(":", 1)
            card = parts[0].split()[1]
            cards[card] = parts[1].strip()
            dev = None
            if "device" in parts[0]:
                try:
                    dev = parts[0].split("device", 1)[1].strip().split()[0]
                except Exception:
                    dev = None
            if card is not None and dev is not None:
                devices.append((f"plughw:{card},{dev}", f"{cards.get(card, '')}".strip()))
        elif line.startswith("device ") and card is not None:
            try:
                dev = line.split(":", 1)[0].split()[1]
                devices.append((f"plughw:{card},{dev}", f"{cards.get(card, '')}".strip()))
            except Exception:
                pass

    # common logical devices
    devices.insert(0, ("default", "ALSA default"))
    out_l = _run_text(["arecord", "-L"], timeout=3)
    if "pulse" in out_l.split():
        devices.insert(0, ("pulse", "PulseAudio"))

    seen = set()
    uniq: List[Tuple[str, str]] = []
    for d, desc in devices:
        if d in seen:
            continue
        seen.add(d)
        uniq.append((d, desc))
    return uniq


def list_playback_devices_linux() -> List[Tuple[str, str]]:
    devices: List[Tuple[str, str]] = []
    out = _run_text(["aplay", "-l"], timeout=3)
    cards = {}
    card = None
    for line in out.splitlines():
        line = line.strip()
        if line.startswith("card ") and ":" in line:
            parts = line.split(":", 1)
            card = parts[0].split()[1]
            cards[card] = parts[1].strip()
            dev = None
            if "device" in parts[0]:
                try:
                    dev = parts[0].split("device", 1)[1].strip().split()[0]
                except Exception:
                    dev = None
            if card is not None and dev is not None:
                devices.append((f"plughw:{card},{dev}", f"{cards.get(card, '')}".strip()))
        elif line.startswith("device ") and card is not None:
            try:
                dev = line.split(":", 1)[0].split()[1]
                devices.append((f"plughw:{card},{dev}", f"{cards.get(card, '')}".strip()))
            except Exception:
                pass

    devices.insert(0, ("default", "ALSA default"))
    out_l = _run_text(["aplay", "-L"], timeout=3)
    if "pulse" in out_l.split():
        devices.insert(0, ("pulse", "PulseAudio"))

    seen = set()
    uniq: List[Tuple[str, str]] = []
    for d, desc in devices:
        if d in seen:
            continue
        seen.add(d)
        uniq.append((d, desc))
    return uniq


def get_active_pulse_devices() -> Tuple[Optional[str], Optional[str]]:
    if not shutil.which("pactl"):
        return None, None
    src = None
    sink = None
    out = _run_text(["pactl", "get-default-source"], timeout=2).strip()
    if out:
        src = out.splitlines()[-1].strip()
    out = _run_text(["pactl", "get-default-sink"], timeout=2).strip()
    if out:
        sink = out.splitlines()[-1].strip()
    return src, sink


def analyze_wav(path: str) -> dict:
    try:
        with wave.open(path, "rb") as wf:
            channels = wf.getnchannels()
            rate = wf.getframerate()
            width = wf.getsampwidth()
            frames = wf.getnframes()
            raw = wf.readframes(frames)

        if width not in (1, 2, 4) or not raw:
            return {"ok": False, "reason": "unsupported"}

        if width == 1:
            max_int = 127.0
            # unsigned 8-bit PCM
            samples = [(b - 128) for b in raw]
        elif width == 2:
            max_int = 32767.0
            samples = [int.from_bytes(raw[i:i+2], "little", signed=True) for i in range(0, len(raw), 2)]
        else:
            max_int = 2147483647.0
            samples = [int.from_bytes(raw[i:i+4], "little", signed=True) for i in range(0, len(raw), 4)]

        if channels > 1:
            # average channels
            mono = []
            for i in range(0, len(samples), channels):
                chunk = samples[i:i+channels]
                if not chunk:
                    break
                mono.append(sum(chunk) / len(chunk))
            samples_f = mono
        else:
            samples_f = samples

        n = len(samples_f)
        if n == 0:
            return {"ok": False, "reason": "empty"}

        peak = max(abs(float(s)) for s in samples_f)
        mean_sq = sum((float(s) * float(s)) for s in samples_f) / n
        rms = math.sqrt(mean_sq)

        if rms <= 0:
            rms_db = -120.0
        else:
            rms_db = 20.0 * math.log10(rms / max_int)

        if peak <= 0:
            crest_db = 0.0
        else:
            crest_db = 20.0 * math.log10(peak / (rms + 1e-9))

        dur = float(n) / float(rate)

        cls = "speech"
        if rms_db < -45.0:
            cls = "silence"
        elif crest_db < 6.0 and rms_db > -25.0:
            cls = "noise"

        return {
            "ok": True,
            "channels": channels,
            "rate": rate,
            "width": width,
            "duration_s": round(dur, 2),
            "rms_dbfs": round(rms_db, 1),
            "crest_db": round(crest_db, 1),
            "class": cls,
        }
    except Exception:
        return {"ok": False, "reason": "read_error"}


def choose_device_interactive(title: str, devices: List[Tuple[str, str]]) -> Optional[str]:
    cprint(Colors.CYAN, f"\n{title}")
    print("  0. auto")
    for i, (dev, desc) in enumerate(devices, 1):
        print(f"  {i}. {dev}  {desc}")
    while True:
        sel = input("Wyb√≥r (0=auto): ").strip()
        if sel == "" or sel == "0":
            return None
        try:
            idx = int(sel)
            if 1 <= idx <= len(devices):
                return devices[idx - 1][0]
        except ValueError:
            # allow paste device name
            for dev, _ in devices:
                if sel == dev:
                    return dev
        cprint(Colors.RED, "‚ùå Nieprawid≈Çowy wyb√≥r")


class STTProvider:
    name: str = "base"
    description: str = "Base"
    min_ram_gb: float = 0.5
    models: List[Tuple[str, str, float]] = []

    @classmethod
    def is_available(cls, info: SystemInfo):
        return False, "Not implemented"

    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        return False

    @classmethod
    def get_recommended_model(cls, info: SystemInfo) -> Optional[str]:
        return None

    def __init__(self, model: Optional[str] = None, language: str = "pl"):
        self.model = model
        self.language = language

    def transcribe(self, audio_path: str) -> str:
        raise NotImplementedError


class WhisperCppSTT(STTProvider):
    name = "whisper.cpp"
    description = "Offline, fast, CPU-optimized Whisper (recommended)"
    min_ram_gb = 1.0
    models = [
        ("tiny", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin", 0.08),
        ("base", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-base.bin", 0.15),
        ("small", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-small.bin", 0.5),
        ("medium", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-medium.bin", 1.5),
        ("large", "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-large-v3.bin", 3.0),
    ]

    @classmethod
    def is_available(cls, info: SystemInfo):
        for b in ("whisper-cli", "whisper-cpp"):
            if shutil.which(b):
                return True, f"{b} found"
        # legacy
        if shutil.which("main"):
            return True, "main found"
        for p in (
            MODELS_DIR / "whisper.cpp" / "build" / "bin" / "whisper-cli",
            MODELS_DIR / "whisper.cpp" / "build" / "bin" / "main",
            MODELS_DIR / "whisper.cpp" / "main",
        ):
            if p.exists():
                return True, f"whisper.cpp at {p}"
        return False, "whisper.cpp not installed"

    @classmethod
    def get_recommended_model(cls, info: SystemInfo) -> str:
        if info.ram_gb < 2:
            return "tiny"
        if info.ram_gb < 4:
            return "base"
        if info.ram_gb < 8:
            return "small"
        if info.ram_gb < 16:
            return "medium"
        return "large"

    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        cprint(Colors.YELLOW, "üì¶ Installing whisper.cpp...")
        whisper_dir = MODELS_DIR / "whisper.cpp"
        whisper_dir.mkdir(parents=True, exist_ok=True)

        already_built = any(
            p.exists()
            for p in (
                whisper_dir / "build" / "bin" / "whisper-cli",
                whisper_dir / "build" / "bin" / "main",
                whisper_dir / "main",
            )
        )
        if already_built:
            cprint(Colors.GREEN, "‚úÖ whisper.cpp already installed!")
            return True
        try:
            if not (whisper_dir / "Makefile").exists():
                subprocess.run(
                    ["git", "clone", "https://github.com/ggerganov/whisper.cpp", str(whisper_dir)],
                    check=True,
                )
            subprocess.run(["make", "-j"], cwd=whisper_dir, check=True)
            cprint(Colors.GREEN, "‚úÖ whisper.cpp installed!")
            return True
        except Exception as e:
            cprint(Colors.RED, f"‚ùå Installation failed: {e}")
            return False

    @classmethod
    def download_model(cls, model_name: str) -> Optional[Path]:
        model_info = next((m for m in cls.models if m[0] == model_name), None)
        if not model_info:
            cprint(Colors.RED, f"‚ùå Unknown model: {model_name}")
            return None

        name, url, size = model_info
        expected_bytes = int(float(size) * 1024 * 1024 * 1024)
        if name == "large":
            # upstream naming changed to large-v3; accept both
            p1 = MODELS_DIR / "whisper.cpp" / "ggml-large.bin"
            p2 = MODELS_DIR / "whisper.cpp" / "ggml-large-v3.bin"
            if p2.exists() and p2.stat().st_size > max(1024 * 1024, int(expected_bytes * 0.9)):
                return p2
            if p1.exists() and p1.stat().st_size > max(1024 * 1024, int(expected_bytes * 0.9)):
                return p1
            model_path = p2
        else:
            model_path = MODELS_DIR / "whisper.cpp" / f"ggml-{name}.bin"
            if model_path.exists() and model_path.stat().st_size > max(1024 * 1024, int(expected_bytes * 0.9)):
                return model_path

        if model_path.exists() and model_path.stat().st_size > max(1024 * 1024, int(expected_bytes * 0.9)):
            return model_path

        cprint(Colors.YELLOW, f"üì• Downloading {name} model ({size} GB)...")
        model_path.parent.mkdir(parents=True, exist_ok=True)
        try:
            urllib.request.urlretrieve(url, model_path, _download_progress)
            print()
            cprint(Colors.GREEN, f"‚úÖ Model {name} downloaded!")
            return model_path
        except Exception as e:
            cprint(Colors.RED, f"‚ùå Download failed: {e}")
            return None

    def transcribe(self, audio_path: str) -> str:
        whisper_bin = shutil.which("whisper-cli") or shutil.which("whisper-cpp") or shutil.which("main")
        if not whisper_bin:
            candidates = [
                MODELS_DIR / "whisper.cpp" / "build" / "bin" / "whisper-cli",
                MODELS_DIR / "whisper.cpp" / "build" / "bin" / "main",
                MODELS_DIR / "whisper.cpp" / "main",
            ]
            for c in candidates:
                if c.exists():
                    whisper_bin = str(c)
                    break

        model_name = self.model or "base"
        if model_name == "large":
            p2 = MODELS_DIR / "whisper.cpp" / "ggml-large-v3.bin"
            p1 = MODELS_DIR / "whisper.cpp" / "ggml-large.bin"
            model_path = p2 if p2.exists() else p1
        else:
            model_path = MODELS_DIR / "whisper.cpp" / f"ggml-{model_name}.bin"
        if not model_path.exists():
            model_path = self.download_model(model_name)

        if not model_path:
            return ""

        try:
            result = subprocess.run(
                [whisper_bin, "-m", str(model_path), "-l", self.language, "-f", audio_path, "-nt"],
                capture_output=True,
                text=True,
                timeout=120,
            )
            return result.stdout.strip()
        except Exception as e:
            cprint(Colors.RED, f"‚ùå Transcription error: {e}")
            return ""


class TTSProvider:
    name: str = "base"

    @classmethod
    def is_available(cls, info: SystemInfo):
        return False, "Not implemented"

    @classmethod
    def install(cls, info: SystemInfo) -> bool:
        return False

    def __init__(self, voice: str = "pl"):
        self.voice = voice

    def speak(self, text: str) -> None:
        raise NotImplementedError


class EspeakTTS(TTSProvider):
    name = "espeak"

    @classmethod
    def is_available(cls, info: SystemInfo):
        if shutil.which("espeak") or shutil.which("espeak-ng"):
            return True, "espeak found"
        return False, "apt install espeak / espeak-ng"

    def speak(self, text: str) -> None:
        cmd = shutil.which("espeak-ng") or shutil.which("espeak")
        if cmd:
            subprocess.run(
                [cmd, "-v", self.voice, "-s", "160", text],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )


STT_PROVIDERS = {"whisper_cpp": WhisperCppSTT}
TTS_PROVIDERS = {"espeak": EspeakTTS}


def record_audio(duration: int = 5, output_path: str = "/tmp/stts_audio.wav", device: Optional[str] = None) -> str:
    info = detect_system()
    cprint(Colors.GREEN, f"üé§ M√≥w ({duration}s)...", end=" ")
    try:
        if info.os_name == "linux":
            cmd = ["arecord"]
            if device:
                cmd += ["-D", device]
            cmd += [
                "-d",
                str(duration),
                "-r",
                "16000",
                "-c",
                "1",
                "-f",
                "S16_LE",
                "-t",
                "wav",
                output_path,
            ]
            subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=duration + 2)
            print("‚úÖ")
            diag = analyze_wav(output_path)
            if diag.get("ok"):
                cprint(Colors.CYAN, f"üîé audio: {diag['duration_s']}s, {diag['rate']}Hz, rms={diag['rms_dbfs']}dBFS, crest={diag['crest_db']}dB")
                if diag.get("class") == "silence":
                    cprint(Colors.YELLOW, "‚ö†Ô∏è  Brak sygna≈Çu / cisza (sprawd≈∫ mikrofon, mute, wyb√≥r urzƒÖdzenia)")
                elif diag.get("class") == "noise":
                    cprint(Colors.YELLOW, "‚ö†Ô∏è  WyglƒÖda na sam ha≈Ças (sprawd≈∫ gain/≈∫r√≥d≈Ço wej≈õcia)")
            return output_path
        cprint(Colors.RED, "‚ùå Recording supported only on Linux in this minimal build")
        return ""
    except Exception as e:
        cprint(Colors.RED, f"‚ùå Recording failed: {e}")
        return ""


def interactive_setup() -> dict:
    config = load_config()
    info = detect_system()

    cprint(Colors.BOLD + Colors.CYAN, "\nSTTS (python) - Setup\n")
    print(f"OS={info.os_name} RAM={info.ram_gb}GB GPU={info.gpu_name or 'none'}")

    stt_cls = WhisperCppSTT
    available, reason = stt_cls.is_available(info)
    print(f"STT: {stt_cls.name} ({reason})")
    if not available:
        if input("Install whisper.cpp now? (y/n): ").strip().lower() == "y":
            stt_cls.install(info)

    rec = stt_cls.get_recommended_model(info)
    model = input(f"Whisper model [tiny/base/small/medium/large] (ENTER={rec}): ").strip() or rec
    config["stt_provider"] = "whisper_cpp"
    config["stt_model"] = model

    if input(f"Download model {model} now? (y/n): ").strip().lower() == "y":
        stt_cls.download_model(model)

    tts_cls = EspeakTTS
    available, reason = tts_cls.is_available(info)
    print(f"TTS: {tts_cls.name} ({reason})")
    if not available:
        cprint(Colors.YELLOW, "Install espeak: sudo apt install espeak")

    config["tts_provider"] = "espeak" if available else None

    if info.os_name == "linux":
        src, sink = get_active_pulse_devices()
        if src or sink:
            cprint(Colors.CYAN, "\nAktywne urzƒÖdzenia (PulseAudio):")
            if src:
                print(f"  mic: {src}")
            if sink:
                print(f"  speaker: {sink}")

        mics = list_capture_devices_linux()
        spk = list_playback_devices_linux()
        config["mic_device"] = choose_device_interactive("Wybierz mikrofon (arecord)", mics)
        config["speaker_device"] = choose_device_interactive("Wybierz g≈Ço≈õnik (info)", spk)
        auto_sw = input("Auto-prze≈ÇƒÖczanie mikrofonu gdy cisza/ha≈Ças? (ENTER=y / n): ").strip().lower()
        config["audio_auto_switch"] = (auto_sw != "n")

    save_config(config)
    cprint(Colors.GREEN, f"‚úÖ Saved: {CONFIG_FILE}")
    return config


def nlp2cmd_translate(text: str) -> Optional[str]:
    if os.environ.get("STTS_NLP2CMD_ENABLED", "0").strip() not in ("1", "true", "yes", "y"):
        return None
    bin_name = os.environ.get("STTS_NLP2CMD_BIN", "nlp2cmd")
    args = shlex.split(os.environ.get("STTS_NLP2CMD_ARGS", "-r"))
    if not shutil.which(bin_name):
        cprint(Colors.YELLOW, f"‚ö†Ô∏è  {bin_name} nie znaleziony. Zainstaluj: pip install nlp2cmd")
        return None
    try:
        res = subprocess.run([bin_name, *args, text], capture_output=True, text=True, timeout=60)
        out = (res.stdout or "") + (res.stderr or "")
        lines = [l.strip() for l in out.splitlines() if l.strip()]
        if not lines:
            return None

        # heuristic: first plausible command-like line
        for l in lines:
            if l.startswith("```"):
                continue
            if l.startswith("üìä"):
                continue
            if l.lower().startswith("time:"):
                continue
            if l.startswith("$"):
                return l.lstrip("$").strip()
            # shell-ish / sql-ish
            if any(x in l for x in (" ", ";", "|", "&&", "||", "SELECT", "select", "docker", "kubectl", "git")):
                return l
            if l and all(ch.isalnum() or ch in ("-", "_", ".") for ch in l):
                return l
        return lines[0]
    except Exception:
        return None


def nlp2cmd_confirm(cmd: str) -> bool:
    if os.environ.get("STTS_NLP2CMD_CONFIRM", "1").strip() in ("0", "false", "no", "n"):
        return True
    print(f"\nNLP2CMD ‚Üí {cmd}")
    ans = input("Uruchomiƒá tƒô komendƒô? (y/n): ").strip().lower()
    return ans == "y"


def _has_pexpect() -> bool:
    try:
        import pexpect  # noqa: F401

        return True
    except Exception:
        return False


class VoiceShell:
    def __init__(self, config: dict):
        self.config = config
        self.info = detect_system()
        self.stt = self._init_stt()
        self.tts = self._init_tts()

        HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
        if HISTORY_FILE.exists():
            readline.read_history_file(str(HISTORY_FILE))
        atexit.register(lambda: readline.write_history_file(str(HISTORY_FILE)))

    def _init_stt(self) -> Optional[STTProvider]:
        provider = self.config.get("stt_provider")
        if provider in STT_PROVIDERS:
            cls = STT_PROVIDERS[provider]
            available, _ = cls.is_available(self.info)
            if available:
                return cls(model=self.config.get("stt_model"), language=self.config.get("language", "pl"))
        return None

    def _init_tts(self) -> Optional[TTSProvider]:
        provider = self.config.get("tts_provider")
        if provider in TTS_PROVIDERS:
            cls = TTS_PROVIDERS[provider]
            available, _ = cls.is_available(self.info)
            if available:
                return cls(voice=self.config.get("tts_voice", "pl"))
        if shutil.which("espeak") or shutil.which("espeak-ng"):
            return EspeakTTS(self.config.get("tts_voice", "pl"))
        return None

    def speak(self, text: str):
        if self.tts and self.config.get("auto_tts", True):
            threading.Thread(target=self.tts.speak, args=(text[:200],), daemon=True).start()

    def transcribe(self, audio_path: str) -> str:
        if os.environ.get("STTS_MOCK_STT") == "1":
            sidecar = Path(audio_path).with_suffix(Path(audio_path).suffix + ".txt")
            if sidecar.exists():
                try:
                    return sidecar.read_text(encoding="utf-8").strip()
                except Exception:
                    return ""
        if not self.stt:
            return ""
        cprint(Colors.YELLOW, "üîÑ Rozpoznawanie...", end=" ")
        text = self.stt.transcribe(audio_path)
        if text:
            cprint(Colors.GREEN, f"‚úÖ \"{text}\"")
        else:
            cprint(Colors.RED, "‚ùå Nie rozpoznano")
        return text

    def listen(self, stt_file: Optional[str] = None) -> str:
        mic = self.config.get("mic_device")
        audio_path = stt_file or record_audio(self.config.get("timeout", 5), device=mic)
        if not audio_path:
            return ""
        diag = analyze_wav(audio_path)
        if diag.get("ok") and diag.get("class") in ("silence", "noise") and stt_file is None:
            if self.config.get("audio_auto_switch") and self.info.os_name == "linux":
                cprint(Colors.YELLOW, "üîÅ Pr√≥ba auto-wyboru mikrofonu...")
                candidates = list_capture_devices_linux()
                best = None
                best_score = -1e9
                for dev, _ in candidates[:6]:
                    if mic and dev == mic:
                        continue
                    tmp = "/tmp/stts_probe.wav"
                    p = record_audio(2, output_path=tmp, device=dev)
                    if not p:
                        continue
                    d = analyze_wav(p)
                    if not d.get("ok"):
                        continue
                    score = float(d.get("rms_dbfs", -120)) + float(d.get("crest_db", 0))
                    if d.get("class") != "silence" and score > best_score:
                        best = dev
                        best_score = score
                if best:
                    cprint(Colors.GREEN, f"‚úÖ Wybrano mikrofon: {best}")
                    self.config["mic_device"] = best
                    save_config(self.config)
                    audio_path = record_audio(self.config.get("timeout", 5), device=best)
                    if not audio_path:
                        return ""
        return self.transcribe(audio_path)

    def run_command(self, cmd: str):
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=60)
            return result.stdout + result.stderr, result.returncode
        except subprocess.TimeoutExpired:
            return "‚è∞ Timeout (60s)", 124
        except Exception as e:
            return f"‚ùå Error: {e}", 1

    def run_command_any(self, cmd: str):
        # If pexpect exists, support interactive prompts with TTS + voice reply.
        if sys.stdin.isatty() and _has_pexpect():
            try:
                return self.run_command_interactive(cmd)
            except Exception:
                pass
        out, code = self.run_command(cmd)
        return out, code, False

    def run_command_interactive(self, cmd: str):
        import pexpect

        if os.name != "nt":
            child = pexpect.spawn("/bin/bash", ["-lc", cmd], encoding="utf-8", timeout=1)
        else:
            child = pexpect.spawn(cmd, encoding="utf-8", timeout=1)
        output_parts: List[str] = []
        last_nonempty = ""
        printed = False

        def _flush(text: str):
            nonlocal last_nonempty, printed
            if text:
                printed = True
                print(text, end="", flush=True)
                output_parts.append(text)
                for line in text.splitlines():
                    s = line.strip()
                    if s:
                        last_nonempty = s

        while True:
            try:
                idx = child.expect(["\n", pexpect.EOF, pexpect.TIMEOUT])
                if idx == 0:
                    _flush(child.before + "\n")
                elif idx == 1:
                    _flush(child.before)
                    break
                else:
                    # No output for a moment -> likely waiting for input
                    pending = (child.before or "").strip()
                    prompt_text = pending or last_nonempty
                    if prompt_text:
                        cprint(Colors.MAGENTA, f"üì¢ {prompt_text[:120]}")
                        self.speak(prompt_text)

                    ans = input("üé§ Odpowied≈∫ g≈Çosem? (y/n, ENTER=klawiatura): ").strip().lower()
                    if ans == "y":
                        reply = self.listen()
                        if not reply:
                            reply = input("‚å®Ô∏è  Odpowied≈∫: ")
                    else:
                        reply = input("‚å®Ô∏è  Odpowied≈∫: ")
                    child.sendline(reply)
            except pexpect.exceptions.EOF:
                break

        try:
            child.close()
        except Exception:
            pass

        code = child.exitstatus if child.exitstatus is not None else (child.status or 0)
        return "".join(output_parts), code, printed

    def run(self):
        PS1 = f"{Colors.GREEN}üîä stts(py)>{Colors.NC} "
        cprint(Colors.BOLD + Colors.CYAN, "\nSTTS (python) - Voice Shell\n")
        if self.info.os_name == "linux":
            src, sink = get_active_pulse_devices()
            if src or sink:
                cprint(Colors.CYAN, "Aktywne urzƒÖdzenia (PulseAudio):")
                if src:
                    print(f"  mic: {src}")
                if sink:
                    print(f"  speaker: {sink}")
        print("Komendy: ENTER=STT, 'exit'=wyj≈õcie, 'setup'=konfiguracja, 'audio'=urzƒÖdzenia")

        while True:
            try:
                cmd = input(PS1).strip()
                if cmd in ["exit", "quit", "q"]:
                    break
                if cmd == "setup":
                    self.config = interactive_setup()
                    self.stt = self._init_stt()
                    self.tts = self._init_tts()
                    continue
                if cmd == "audio" and self.info.os_name == "linux":
                    self.config["mic_device"] = choose_device_interactive("Wybierz mikrofon (arecord)", list_capture_devices_linux())
                    self.config["speaker_device"] = choose_device_interactive("Wybierz g≈Ço≈õnik (info)", list_playback_devices_linux())
                    save_config(self.config)
                    continue
                if cmd.startswith("nlp "):
                    nl = cmd[4:].strip()
                    if not nl:
                        continue
                    translated = nlp2cmd_translate(nl)
                    if translated and nlp2cmd_confirm(translated):
                        cmd = translated
                    else:
                        continue
                if not cmd:
                    cmd = self.listen()
                    if not cmd:
                        continue
                    translated = nlp2cmd_translate(cmd)
                    if translated and nlp2cmd_confirm(translated):
                        cmd = translated

                cprint(Colors.BLUE, f"‚ñ∂Ô∏è  {cmd}")
                output, code, printed = self.run_command_any(cmd)
                if output.strip() and not printed:
                    print(output)

                lines = [l.strip() for l in output.splitlines() if l.strip()]
                if lines:
                    last = lines[-1]
                    if last != cmd and len(last) > 3:
                        cprint(Colors.MAGENTA, f"üì¢ {last[:80]}")
                        self.speak(last)

                if code != 0:
                    cprint(Colors.RED, f"‚ùå Exit code: {code}")
            except KeyboardInterrupt:
                print()
                continue
            except EOFError:
                break


def parse_args(argv: List[str]):
    stt_file = None
    stt_only = False
    setup = False
    help_ = False
    rest: List[str] = []

    it = iter(argv)
    for a in it:
        if a == "--stt-file":
            stt_file = next(it, None)
        elif a == "--stt-only":
            stt_only = True
        elif a == "--setup":
            setup = True
        elif a in ("--help", "-h"):
            help_ = True
        else:
            rest.append(a)
    return stt_file, stt_only, setup, help_, rest


def main():
    config = load_config()
    stt_file, stt_only, setup, help_, rest = parse_args(sys.argv[1:])

    if help_:
        print(__doc__)
        return 0

    if setup or (config.get("stt_provider") is None and config.get("tts_provider") is None and not rest and not stt_file):
        config = interactive_setup()

    shell = VoiceShell(config)

    if stt_file:
        text = shell.listen(stt_file=stt_file)
        if stt_only:
            print(text)
            return 0 if text else 1
        if text:
            translated = nlp2cmd_translate(text)
            if translated and nlp2cmd_confirm(translated):
                text = translated
            out, code = shell.run_command(text)
            if out.strip():
                print(out)
            return code
        return 1

    if not rest:
        shell.run()
        return 0

    cmd = " ".join(rest)
    out, code = shell.run_command(cmd)
    if out.strip():
        print(out)
    lines = [l.strip() for l in out.splitlines() if l.strip()]
    if lines and shell.tts and config.get("auto_tts", True):
        shell.tts.speak(lines[-1][:200])
    return code


if __name__ == "__main__":
    raise SystemExit(main())
